# 데이터베이스

데이터베이스 : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음. 해당 데이터베이스를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)라고 하며, 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다. 또한 데이터베이스는 실시간 접근과 동시 공유가 가능하다

응용 프로그램 ↔ DBMS ↔ 데이터베이스

응용 프로그램 - Node.js, Java

DBMS - MySQL

응용프로그램에서 데이터베이스 안에 있는 데이터를 이용해서 해당 데이터 관련 로직을 구축할 수 있다

## 엔티티

사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미

회원 엔티티 - 이름, 아이디, 주소, 전화번호의 속성을 가진다

### 약한 엔티티와 강한 엔티티

A가 혼자서 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔티티, B는 강한 엔티티가 된다. 

ex) 방 - 약한 엔티티, 건물 - 강한 엔티티

### 릴레이션

데이터베이스에서 정보를 구분하여 저장하는 기본 단위. 엔티티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다

관계형 데이터베이스 - 테이블

NoSQL - 컬렉션

### 테이블과 컬렉션

- 관계형 데이터베이스 MySQL : 레코드-테이블-데이터베이스
- NoSQL MongoDB : 도큐먼트-컬렉션-데이터베이스

### 속성

릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

ex) 차(엔티티)의 속성에는 차 넘버, 바퀴 수, 차 색깔, 차 종 등이 있다

이 중 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔티티의 속성이 된다

### 도메인

릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

ex) 성별(속성) - {남,여}(도메인)

### 필드와 레코드

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/c6d9c314-e275-4f99-8c89-a85a503d7a86)


회원 (엔티티)

member (테이블)

이름, 아이디 (속성)

name, ID, address (필드)

테이블에 쌓이는 행(row) 단위의 데이터를 레코드(=튜플) 라고 한다

엔티티를 데이터베이스에 넣어 테이블로 만들기 위해선 속성에 맞는 타입을 정의해야 한다.

ex) 책의 아이디 : INT, 책의 제목 : VARCHAR … 

```sql
CREATE TABLE book(
	id INT NOT NULL AUTO_INCREMENT,
	title VARCHAR(255)
);
```

- 필드 : 타입을 갖는다. 이름 - 문자열, 전화번호 - 숫자
    - 숫자 : TINYINY, MEDIUMINT, INT, BIGINT 등
        
        ![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/5784ad51-2b4a-4452-b54c-6e498228d458)
        
    - 날짜
        - DATE : 날짜 부분은 있지만 시간 부분은 없는 값에 사용. 1000-01-01 ~ 9999-12-31. 3byte
        - DATETIME : 날짜 및 시간 부분을 모두 포함하는 값에 사용. 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59. 8byte
        - TIMESTAMP : 날짜 및 시간 부분을 모두 포함하는 값에 사용. 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07. 4byte
    - 문자 : CHAR, VARCHAR 모두 그 안에 수를 입력해서 몇 자까리 입력할지 정한다. ex) CHAR(30) : 최대 30글자까지 입력
        - CHAR : 테이블을 생성할 때 선언한 길이로 고정. 길이는 0에서 255 사이의 값을 가진다. 레코를 저장할 때 무조건 선언한 길이 값으로 ‘고정’
        - VARCHAR : 가변 길이 문자열. 길이는 0에서 65,535 사이의 값으로 지정. 입력된 데이터에 따라 용량을 가변시켜 저장한다.
        ex) 10글자에 해당하는 바이트 + 길이 기록용 1바이트
        
        CHAR - 유동적이지 않은 길이응 데이터의 경우 효율적, VARCHAR - 유동적인 길이를 가진 데이터에 효율적
        
        - TEXT : 큰 문자열 저장. ex) 게시판의 본문
        - BLOB : 이미지, 동영상 등 큰 데이터 저장. 그러나 S3를 이용하면 파일에 관한 경로를 VARCHAR로 저장한다
        
        ENUM, SET은 모두 문자열을 열거한 타입
        
        - ENUM : ENUM(’x-small’, ‘small’, ‘medium’ … ) 형태로 사용. 이 중 하나만 선택하는 단일 선택만 가능하고 이넘 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다. 이넘을 이용하면 x-small 등이 0,1 등으로 매핑되어 메모리를 적게 사용한다. 최대 65,535개의 요소 삽입 가능
        - SET : 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다
        
        장점 : ENUM, SET을 사용할 경우 공간적으로 이점
        단점 : 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록을 수정해야 한다
        

### 관계

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/a15d101d-852f-48ba-9788-dbe38e24091c)


- 1:1 관계 : 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어 준다
- 1:N 관계 : 한 유저당 여러 개의 상품을 장바구니에 넣을 수 있다. 하나도 넣지 않는 0개의 경우도 있으니 0도 포함되는 화살표를 통해 표현해야 한다
- N:M 관계 : 학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있다. N:M은 테이블 두 개를 직접 연결해서 구축하지 않고 1:N, 1:M 관계를 갖는 테이블 두 개로 나눠 설정한다
    
    ![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/81cdcdee-1a1a-4806-ada6-0526ee23aaa4)

    

### 키

테이블 간의 관계를 조금 더 명확하고 테이블 자체의 인덱스를 위해 설정된 장치

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/f6eeb0bb-b2ee-4a34-9296-c8773d149ba8)

슈퍼키 - 유일성, 그 안에 포함된 후보키는 최소성까지 갖춘 키, 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 된다. 유일성을 중복되는 값은 없으며, 최소성을 필드를 조합하지 않고 최소 필드만 사용해서 키를 형성할 수 있다

- 기본키 : PK, 프라이머리키. 유일성과 최소성을 만족한다. 기본키에 해당하는 데이터는 중복을 허용하지 않는다. 복합키를 기본키로 설정하면 최소성을 만족하지 않는다. 기본키는 자연키 또는 인조키 중 골라 설정한다
- 자연키 : 중복된 값들을 제외하며 중복되지 않는 것을 뽑아서 나오는 키를 자연키라고 한다. 언젠가는 변하는 속성을 가진다.
- 인조키 : 오라클 - sequence, MySQL - auto_increment 등으로 설정. 인위적으로 생성한 키를 인조키라고 한다. 자연키와는 반대로 변하지 않는다. 따라서 보통 기본키는 인조키로 설정한다
- 외래키 : FK, 다른 테이블의 기본키를 그대로 참조하는 값. 개체와의 관계를 식별하는 데 사용된다. 중복 허용
- 후보키 : 기본키가 될 수 있는 후보들, 유일성과 최소성을 동시에 만족하는 키
- 대체키 : 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말한다
- 슈퍼키 : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키


## 🤔 생각해볼 점

- PK는 자연키나 인조키 중에 설정할 수 있다

자연키는 중복된 값을 제외하고 중복되지 않는 값을 뽑아서 나오는 키라고 한다. 예를 들어 회원 테이블에서 회원 정보 중 ‘아이디’ 속성을 자연키로 설정한다. 이메일은 데이터베이스 레코드 상에선 유니크하지만 현실에선 바뀔 수 있는 값이다.(물론 수정을 허용하지 않으면 유일할 수 있다) 그래서 보통 변하지 않는 인조키로 설정하는 것 같다. 생각해보면 데이터베이스를 설계할 때도 삭제하고 검색하기 용이한 값으로 PK를 지정했던 것 같다.

게시판에서 글을 삭제할 땐 글의 번호, 회원 정보를 삭제 할 땐 회원의 아이디로 검색하는데, 테이블이 매핑되어있기 때문에 삭제할 때 관련 속성을 사용했다.

```java
@DeleteMapping("/api/products/{productId}")
    public ResponseEntity<String> delete(@Login User user, @PathVariable Integer productId) {
        if (productId == null) {
            throw new IllegalArgumentException("상품 ID가 유효하지 않습니다.");
        }
        productService.deleteProduct(productId);
        return new ResponseEntity<>(ResponseMessage.DELETE_PRODUCT_OK, HttpStatus.OK);
    }
```

```java
@Transactional
    public void deleteProduct(Integer productId) {
        Product product = findProductByProductId(productId);
        product.setDeleted(true);
        productRepository.save(product);
    }
```

팀 프로젝트에서 구현 당시 soft delete를 사용했기때문에 완전 삭제를 해주진 않았다.

검색을 할 때도 유저의 아이디를 기반으로 상품 테이블에서 찾았다.

```java
public ProductListDTO getUserSalesProducts(User user, Pageable pageable, ProductSearchCondition productSearchCondition) {
        User savedUser = userRepository.findById(user.getUserId())
                .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 회원입니다"));
        productSearchCondition.setUserId(savedUser.getUserId());

        Slice<Product> productsWithSlice = productRepository.findFilteredProducts(pageable, productSearchCondition);
        List<Product> products = productsWithSlice.getContent();

        return new ProductListDTO(products.stream()
                .map(ProductDTO::new)
                .collect(Collectors.toList()), productsWithSlice.hasNext());
    }
```

테이블 설계 당시 userId를 auto_increment로 설정했기때문에 (깃허브 로그인을 사용해서 나머지는 이름과 아바타(사진)만 가져왔다) 검색하고 삭제하기 용이했던 것 같다. 자연키를 PK로 두는 회사에 간다면 아마 그만한 이유가 있지 않을까? 라고 생각한다.

----

## ERD

데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것이다. 서비스를 구축한다면 가장 먼저 신경 써야 할 부분이며 이 부분을 신경쓰지 않고 서비스를 구축한다면 부실 공사나 다름없다

ERD는  시스템의 요구사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축한다. 데이터베이스를 구축한 이후에도 디버깅 또는 재설계가 필요할 경우 설계도 역할을 한다

관계형 데이터를 구성하는 것엔 유용하지만 비정형 데이터를 충분히 표현할 수 없다는 단점이 있다

> 비정형 데이터?
비 구조화 데이터. 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보
> 

## 정규화 과정

릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나 저장 공간을 효율적으로 사용하기 위해 릴레이션을 분리하는 과정

### 이상현상

- 삽입 이상
- 삭제 이상
- 갱신 이상

정규화 과정은 정규형 원칙을 기반으로 정규형을 만들어가는 과정이며, 정규화된 정도는 정규형(NF, Normal Form)으로 표현한다

기본 - 1,2,3,보이스/코드

고급 - 4,5

### 정규형 원칙

같은 의미를 표현하는 릴레이션이지만 

- 좀 더 좋은 구조로 만들어야 함
- 자료의 중복성 감소
- 독립적인 관계는 별개의 릴레이션으로 표현
- 각각의 릴레이션은 독립적인 표현이 가능

### 제 1 정규형

릴레이션의 모든 도메인이 더이상 분해될 수 없는 원자값만으로 구성되어야 한다. 릴레이션의 속성 값 중 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안된다. 반복 집합이 있다면 제거해야한다

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/3eba33c9-8cbf-4063-b5cb-d12415314952)

### 제 2 정규형

릴레이션이 제 1정규형이며 부분 함수의 종속성을 제거한 상태

→ 값이 두개 이상 있으면 안되며 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것

릴레이션을 분리할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하면 안된다. (무손실 분해)

> 완전 함수 종속적?
기본키가 종속자이며 기본키가 여러 속성으로 구성되어 있을 경우 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우
> 

예제 테이블 :

| 학번 | 학부 | 이름 |
| --- | --- | --- |
| 001 | 컴퓨터 공학과 | 홍길동 |
| 002 | 컴퓨터 공학과 | 이순신 |
| 003 | 전자공학과 | 장보고 |

위와 같은 릴레이션은 학부와 이름이 학번에 종속되어 있습니다. 따라서 이러한 관계를 가집니다.

결정자 : 학번

종속자 : 학부, 이름

candidate key : {학번}

non-prime attribute : 학부, 이름

종속 관계 : {학번 -> 학부, 이름}

이러한 관계에서 종속자는 기본키이며 기본키를 구성하는 모든 속성의 부분집합이 종속자이기 때문에 "학부와 이름은 학번에 완전 함수 종속 되어있다." 라고 말한다

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/5be25bdd-fce8-4493-96ca-464ccf5ac027)

### 제 3 정규형

제 2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태

> 이행적 함수 종속?
A → B, B → C일때 A → C가 성립하는데, 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 한다
> 
> 
![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/a4d6fdbf-61b4-4b13-b39a-7273a6c9a815)

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/7089349a-96a1-4eb5-9ef6-a9bc6a6589d0)

### 보이스/코드 정규형(BCNF)

제 3정규형이고, 결정자가 후보키가 아닌 함주 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

> 결정자?
함수 종속 관계에서 특정 종속자를 결정짓는 요소. X → Y일 때 X는 결정자, Y는 종속자
> 

정규형 과정을 거쳐 테이블을 나눈다 해도 성능이 좋아지는 것은 아니다. 테이블을 나누게 되면 어떤 쿼리에선 조인을 해야하는 경우도 발생해서 오히려 느려질 수도 있기 때문에 서비스에 따라 선택한다
# 데이터베이스

데이터베이스 : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음. 해당 데이터베이스를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)라고 하며, 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다. 또한 데이터베이스는 실시간 접근과 동시 공유가 가능하다

응용 프로그램 ↔ DBMS ↔ 데이터베이스

응용 프로그램 - Node.js, Java

DBMS - MySQL

응용프로그램에서 데이터베이스 안에 있는 데이터를 이용해서 해당 데이터 관련 로직을 구축할 수 있다

## 엔티티

사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미

회원 엔티티 - 이름, 아이디, 주소, 전화번호의 속성을 가진다

### 약한 엔티티와 강한 엔티티

A가 혼자서 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔티티, B는 강한 엔티티가 된다. 

ex) 방 - 약한 엔티티, 건물 - 강한 엔티티

### 릴레이션

데이터베이스에서 정보를 구분하여 저장하는 기본 단위. 엔티티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다

관계형 데이터베이스 - 테이블

NoSQL - 컬렉션

### 테이블과 컬렉션

- 관계형 데이터베이스 MySQL : 레코드-테이블-데이터베이스
- NoSQL MongoDB : 도큐먼트-컬렉션-데이터베이스

### 속성

릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

ex) 차(엔티티)의 속성에는 차 넘버, 바퀴 수, 차 색깔, 차 종 등이 있다

이 중 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔티티의 속성이 된다

### 도메인

릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

ex) 성별(속성) - {남,여}(도메인)

### 필드와 레코드

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/c6d9c314-e275-4f99-8c89-a85a503d7a86)


회원 (엔티티)

member (테이블)

이름, 아이디 (속성)

name, ID, address (필드)

테이블에 쌓이는 행(row) 단위의 데이터를 레코드(=튜플) 라고 한다

엔티티를 데이터베이스에 넣어 테이블로 만들기 위해선 속성에 맞는 타입을 정의해야 한다.

ex) 책의 아이디 : INT, 책의 제목 : VARCHAR … 

```sql
CREATE TABLE book(
	id INT NOT NULL AUTO_INCREMENT,
	title VARCHAR(255)
);
```

- 필드 : 타입을 갖는다. 이름 - 문자열, 전화번호 - 숫자
    - 숫자 : TINYINY, MEDIUMINT, INT, BIGINT 등
        
        ![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/5784ad51-2b4a-4452-b54c-6e498228d458)
        
    - 날짜
        - DATE : 날짜 부분은 있지만 시간 부분은 없는 값에 사용. 1000-01-01 ~ 9999-12-31. 3byte
        - DATETIME : 날짜 및 시간 부분을 모두 포함하는 값에 사용. 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59. 8byte
        - TIMESTAMP : 날짜 및 시간 부분을 모두 포함하는 값에 사용. 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07. 4byte
    - 문자 : CHAR, VARCHAR 모두 그 안에 수를 입력해서 몇 자까리 입력할지 정한다. ex) CHAR(30) : 최대 30글자까지 입력
        - CHAR : 테이블을 생성할 때 선언한 길이로 고정. 길이는 0에서 255 사이의 값을 가진다. 레코를 저장할 때 무조건 선언한 길이 값으로 ‘고정’
        - VARCHAR : 가변 길이 문자열. 길이는 0에서 65,535 사이의 값으로 지정. 입력된 데이터에 따라 용량을 가변시켜 저장한다.
        ex) 10글자에 해당하는 바이트 + 길이 기록용 1바이트
        
        CHAR - 유동적이지 않은 길이응 데이터의 경우 효율적, VARCHAR - 유동적인 길이를 가진 데이터에 효율적
        
        - TEXT : 큰 문자열 저장. ex) 게시판의 본문
        - BLOB : 이미지, 동영상 등 큰 데이터 저장. 그러나 S3를 이용하면 파일에 관한 경로를 VARCHAR로 저장한다
        
        ENUM, SET은 모두 문자열을 열거한 타입
        
        - ENUM : ENUM(’x-small’, ‘small’, ‘medium’ … ) 형태로 사용. 이 중 하나만 선택하는 단일 선택만 가능하고 이넘 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다. 이넘을 이용하면 x-small 등이 0,1 등으로 매핑되어 메모리를 적게 사용한다. 최대 65,535개의 요소 삽입 가능
        - SET : 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다
        
        장점 : ENUM, SET을 사용할 경우 공간적으로 이점
        단점 : 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록을 수정해야 한다
        

### 관계

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/a15d101d-852f-48ba-9788-dbe38e24091c)


- 1:1 관계 : 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어 준다
- 1:N 관계 : 한 유저당 여러 개의 상품을 장바구니에 넣을 수 있다. 하나도 넣지 않는 0개의 경우도 있으니 0도 포함되는 화살표를 통해 표현해야 한다
- N:M 관계 : 학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있다. N:M은 테이블 두 개를 직접 연결해서 구축하지 않고 1:N, 1:M 관계를 갖는 테이블 두 개로 나눠 설정한다
    
    ![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/81cdcdee-1a1a-4806-ada6-0526ee23aaa4)

    

### 키

테이블 간의 관계를 조금 더 명확하고 테이블 자체의 인덱스를 위해 설정된 장치

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/f6eeb0bb-b2ee-4a34-9296-c8773d149ba8)

슈퍼키 - 유일성, 그 안에 포함된 후보키는 최소성까지 갖춘 키, 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 된다. 유일성을 중복되는 값은 없으며, 최소성을 필드를 조합하지 않고 최소 필드만 사용해서 키를 형성할 수 있다

- 기본키 : PK, 프라이머리키. 유일성과 최소성을 만족한다. 기본키에 해당하는 데이터는 중복을 허용하지 않는다. 복합키를 기본키로 설정하면 최소성을 만족하지 않는다. 기본키는 자연키 또는 인조키 중 골라 설정한다
- 자연키 : 중복된 값들을 제외하며 중복되지 않는 것을 뽑아서 나오는 키를 자연키라고 한다. 언젠가는 변하는 속성을 가진다.
- 인조키 : 오라클 - sequence, MySQL - auto_increment 등으로 설정. 인위적으로 생성한 키를 인조키라고 한다. 자연키와는 반대로 변하지 않는다. 따라서 보통 기본키는 인조키로 설정한다
- 외래키 : FK, 다른 테이블의 기본키를 그대로 참조하는 값. 개체와의 관계를 식별하는 데 사용된다. 중복 허용
- 후보키 : 기본키가 될 수 있는 후보들, 유일성과 최소성을 동시에 만족하는 키
- 대체키 : 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말한다
- 슈퍼키 : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키


## 🤔 생각해볼 점

- PK는 자연키나 인조키 중에 설정할 수 있다

자연키는 중복된 값을 제외하고 중복되지 않는 값을 뽑아서 나오는 키라고 한다. 예를 들어 회원 테이블에서 회원 정보 중 ‘아이디’ 속성을 자연키로 설정한다. 이메일은 데이터베이스 레코드 상에선 유니크하지만 현실에선 바뀔 수 있는 값이다.(물론 수정을 허용하지 않으면 유일할 수 있다) 그래서 보통 변하지 않는 인조키로 설정하는 것 같다. 생각해보면 데이터베이스를 설계할 때도 삭제하고 검색하기 용이한 값으로 PK를 지정했던 것 같다.

게시판에서 글을 삭제할 땐 글의 번호, 회원 정보를 삭제 할 땐 회원의 아이디로 검색하는데, 테이블이 매핑되어있기 때문에 삭제할 때 관련 속성을 사용했다.

```java
@DeleteMapping("/api/products/{productId}")
    public ResponseEntity<String> delete(@Login User user, @PathVariable Integer productId) {
        if (productId == null) {
            throw new IllegalArgumentException("상품 ID가 유효하지 않습니다.");
        }
        productService.deleteProduct(productId);
        return new ResponseEntity<>(ResponseMessage.DELETE_PRODUCT_OK, HttpStatus.OK);
    }
```

```java
@Transactional
    public void deleteProduct(Integer productId) {
        Product product = findProductByProductId(productId);
        product.setDeleted(true);
        productRepository.save(product);
    }
```

팀 프로젝트에서 구현 당시 soft delete를 사용했기때문에 완전 삭제를 해주진 않았다.

검색을 할 때도 유저의 아이디를 기반으로 상품 테이블에서 찾았다.

```java
public ProductListDTO getUserSalesProducts(User user, Pageable pageable, ProductSearchCondition productSearchCondition) {
        User savedUser = userRepository.findById(user.getUserId())
                .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 회원입니다"));
        productSearchCondition.setUserId(savedUser.getUserId());

        Slice<Product> productsWithSlice = productRepository.findFilteredProducts(pageable, productSearchCondition);
        List<Product> products = productsWithSlice.getContent();

        return new ProductListDTO(products.stream()
                .map(ProductDTO::new)
                .collect(Collectors.toList()), productsWithSlice.hasNext());
    }
```

테이블 설계 당시 userId를 auto_increment로 설정했기때문에 (깃허브 로그인을 사용해서 나머지는 이름과 아바타(사진)만 가져왔다) 검색하고 삭제하기 용이했던 것 같다. 자연키를 PK로 두는 회사에 간다면 아마 그만한 이유가 있지 않을까? 라고 생각한다.

----

## ERD

데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것이다. 서비스를 구축한다면 가장 먼저 신경 써야 할 부분이며 이 부분을 신경쓰지 않고 서비스를 구축한다면 부실 공사나 다름없다

ERD는  시스템의 요구사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축한다. 데이터베이스를 구축한 이후에도 디버깅 또는 재설계가 필요할 경우 설계도 역할을 한다

관계형 데이터를 구성하는 것엔 유용하지만 비정형 데이터를 충분히 표현할 수 없다는 단점이 있다

> 비정형 데이터?
비 구조화 데이터. 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보
> 

## 정규화 과정

릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나 저장 공간을 효율적으로 사용하기 위해 릴레이션을 분리하는 과정

### 이상현상

- 삽입 이상
- 삭제 이상
- 갱신 이상

정규화 과정은 정규형 원칙을 기반으로 정규형을 만들어가는 과정이며, 정규화된 정도는 정규형(NF, Normal Form)으로 표현한다

기본 - 1,2,3,보이스/코드

고급 - 4,5

### 정규형 원칙

같은 의미를 표현하는 릴레이션이지만 

- 좀 더 좋은 구조로 만들어야 함
- 자료의 중복성 감소
- 독립적인 관계는 별개의 릴레이션으로 표현
- 각각의 릴레이션은 독립적인 표현이 가능

### 제 1 정규형

릴레이션의 모든 도메인이 더이상 분해될 수 없는 원자값만으로 구성되어야 한다. 릴레이션의 속성 값 중 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안된다. 반복 집합이 있다면 제거해야한다

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/3eba33c9-8cbf-4063-b5cb-d12415314952)

### 제 2 정규형

릴레이션이 제 1정규형이며 부분 함수의 종속성을 제거한 상태

→ 값이 두개 이상 있으면 안되며 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것

릴레이션을 분리할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하면 안된다. (무손실 분해)

> 완전 함수 종속적?
기본키가 종속자이며 기본키가 여러 속성으로 구성되어 있을 경우 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우
> 

예제 테이블 :

| 학번 | 학부 | 이름 |
| --- | --- | --- |
| 001 | 컴퓨터 공학과 | 홍길동 |
| 002 | 컴퓨터 공학과 | 이순신 |
| 003 | 전자공학과 | 장보고 |

위와 같은 릴레이션은 학부와 이름이 학번에 종속되어 있습니다. 따라서 이러한 관계를 가집니다.

결정자 : 학번

종속자 : 학부, 이름

candidate key : {학번}

non-prime attribute : 학부, 이름

종속 관계 : {학번 -> 학부, 이름}

이러한 관계에서 종속자는 기본키이며 기본키를 구성하는 모든 속성의 부분집합이 종속자이기 때문에 "학부와 이름은 학번에 완전 함수 종속 되어있다." 라고 말한다

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/5be25bdd-fce8-4493-96ca-464ccf5ac027)

### 제 3 정규형

제 2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태

> 이행적 함수 종속?
A → B, B → C일때 A → C가 성립하는데, 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 한다
> 
> 
![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/a4d6fdbf-61b4-4b13-b39a-7273a6c9a815)

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/7089349a-96a1-4eb5-9ef6-a9bc6a6589d0)

### 보이스/코드 정규형(BCNF)

제 3정규형이고, 결정자가 후보키가 아닌 함주 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

> 결정자?
함수 종속 관계에서 특정 종속자를 결정짓는 요소. X → Y일 때 X는 결정자, Y는 종속자
> 

정규형 과정을 거쳐 테이블을 나눈다 해도 성능이 좋아지는 것은 아니다. 테이블을 나누게 되면 어떤 쿼리에선 조인을 해야하는 경우도 발생해서 오히려 느려질 수도 있기 때문에 서비스에 따라 선택한다

----

## 트랜잭션

트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말한다. 데이터베이스는 쿼리로 접근하는데 여러 개의 쿼리들을 하나로 묶는 단위를 말한다

- ACID
    - 원자성
    - 일관성
    - 독립성
    - 지속성

### 원자성(Atomicity)

“all or nothing”

트랜잭션과 관련된 일이 모두 수행되었거나 모두 수행되지 않음을 보장하는 특징이다.

트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안된다.

- 커밋
여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장된다
커밋이 수행되었다 = 하나의 트랜잭션이 성공적으로 수행되었다
update, insert, delete의 쿼리가 하나의 트랜잭션 단위로 수행되고 이후 데이터베이스에 영구적으로 저장된다
- 롤백
에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야한다?
롤백이란 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)를 말한다

이런 커밋과 롤백 덕에 데이터의 무결성이 보장된다. 또한 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있다

- 트랜잭션 전파
트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 하는데, 이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다
Spring 프레임워크에서는 @Transactional 어노테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리한다

### 일관성(Consistency)

허용된 방식으로만 데이터를 변경해야하는 것을 의미한다.

예를 들자면 통장에 100만원이 있는데 200만원을 이체 하는 것은 불가능하다.

### 격리성(Isolation)

트랜잭션 수행 시 서로 끼어들지 못하는 것을 말한다. 복수의 병렬 트랜잭션은 서로 격리되어 순차적으로 실행되는 것 처럼 작동되어야 하고 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야한다. 순차적으로 하면 쉽지만 성능이 나빠진다.

격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장한다

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/67215040-9735-4b57-b0a2-b6dfb4fa64ab)


READ_UNCOMMITTED는 동시성은 강하지만 격리성은 약하고

SERIALIZABLE은 동시성은 약해지고 격리성은 강해진다

**격리 수준에 따라 발생하는 현상**

- 팬텀리드(phantom read)
한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말한다
- 반복 가능하지 않은 조회(non-repeatable read)
한 트랜잭션 내에 같은 행에 두번 이상 조회가 발생했는데, 그 값이 다른 경우를 말한다.
    - 팬텀 리드와 차이점?
    반복 가능하지 않은 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 다른 행이 선택 될 수도 있다
- 더티 리드(dirty read)
반복 가능하지 않은 조회와 유사하고 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생한다.

**격리 수준**

- Serializable
트랜잭션을 순차적으로 진행시키는 것을 말한다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다. 이 수준은 매우 엄격한 수준으로 해당 행에 대해 격리시키고 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야 한다. 
교착 상태가 일어날 확률이 많고 가장 성능이 떨어지는 격리 수준
- Repeatable_read
하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않기때문에 이후에 추가된 행이 발견될 수 있다
- READ_COMMITTED
가장 많이 사용되는 격리 수준. MySQL8.0, PostgreSQL, SQLserver, 오라클에서 기본값으로 설정되어 있다. 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없고 커밋이 완료된 데이터에 대해서만 조회를 허용한다.
하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다. 이 ㄷ때문에 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있다
- READ_UNCOMMITTED
가장 낮은 격리 수준. 하나의 트랜잭션이 커밋되지 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다. 데이터 무결성을 위해 사용하지 않는 것이 좋지만 거대한 양의 데이터를 어림잡아 집계하는데 사용할 때 좋다

### 지속성(Durability)

성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다는 것을 의미한다. 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 하는 것을 뜻하며, 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공한다

> 체크섬?
중복 검사의 한 형태로 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
> 

> 저널링?
파일 시스템 또는 데이터베이스 시스템에 변경사항을 커밋하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대해 로그를 남기는 것
> 

## 무결성

데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다. 

- 개체 무결성 : 기본키로 선택된 필드는 빈 값을 허용하지 않는다
- 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어지는 경우 그 속성 값은 모두 고유한 값을 가진다
- NULL 무결성 : 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값을 NULL이 될 수 없다는 제약 조건
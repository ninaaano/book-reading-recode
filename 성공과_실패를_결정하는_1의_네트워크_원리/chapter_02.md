# TCP/IP의 데이터를 전기 신호로 만들어 보낸다
## 프로토콜 스택과 LAN 어탭터의 탐험

### 이번 주제 목차
1. 소켓을 작성한다  
애플리케이션에서 의뢰를 받은 프로토콜 스택이 TCP 프로토콜을 이용하여 메시지를 송신하는 동작은 4단계로 요약할 수 있다
- 소켓을 만드는 단계   
프로토콜 스택의 내부 구성, 소켓의 실체, 소켓을 만드는 동작 설명. 소켓이 무엇인지 이해 가능

2. 서버에 접속한다  
클라이언트측의 소켓을 서버측의 소켓에 접속하는 단계.
- 접속한다는게 무엇일까?
- 프로토콜 스택은 어떻게 움직이고 서버와 무슨 대화를 할까?

3. 데이터를 송,수신한다  
소켓이 연결되면 메세지를 송신한다. 프로토콜 스택은 애플리케이션에서 의뢰받은 메세지를 작은 조각으로 분할하여 서버를 향해 송신한다. 오류 때문에 패킷이 없어진다고 가상하여 분할한 조각이 제대로 서버측에 도착했는지 확인하고 도착하지 않았다면 다시 한번 보낸다
4. 서버에서 연결을 끊어 소켓을 말소한다  
메세지 송,수신이 끝나면 서버에서 연결을 끊고 소켓을 말소한다. 연결 끊기 동작의 역할은 메세지 송,수신이 끝난 것을 클라이언트와 서버가 함께 확인하는 것인데, 단순히 확인하고 소켓을 말소하기만 하는 것은 아니다
5. IP와 이더넷의 패킷 송,수신 동작  
프로토콜 스택과 LAN 어댑터가 연대하여 작은 조각으로 분할한 데이터를 패킷 형태로 묶고 그것을 전기나 빛의 신호로 변환하여 케이블에 송출하는 모습을 설명한다
6. UDP 프로토콜을 이용한 송,수신 동작  
TCP 프로토콜에는 편리한 기능이 많다. UDP의 필요성과 TCP와의 차이점을 설명한다
  
<br/>

# [STORY 01] 소켓을 작성한다

## 프로토콜 스택의 내부 구성
OS에 내장된 네트워크 제어용 소프트웨어(프로토콜 스택)와 네트워크용 하드웨어(LAN 어댑터)가 브라우저에서 받은 메시지를 서버에 송출하는 동작을 탐험한다. 프로토콜의 스택은 눈에 보이지 않아서 프로토콜 스택이 어떤 것인지 먼저 알아보자

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/6c16fc9d-a1ec-4701-bd72-af73bccf9247)  
출처 : https://velog.io/@tastestar/2.-TCPIP

### 네트워크 애플리케이션

브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램 해당소켓 라이브러리 안에 리졸버가 내장되어 있다.

> 리졸버?  
> DNS 서버에 조회하는 동작 실행

### 프로토콜 스택

- TCP,UDP : 데이터의 송, 수신 담당. 애플리케이션에서 보낸 의뢰를 받아 송,수신 동작을 실행
    - TCP - 브라우저나 메일 등의 일반적인 애플리케이션에서 사용
    - UDP - DNS 서버 조회 등의 짧은 데이터 송수신 하는 경우 사용
- IP : 패킷 송, 수신 동작을 제어하는 부분
인터넷에서 데이터를 운반할 때는 패킷이라는 형태로 운반하는데, 이 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할이다.
    - ICMP - 패킷을 운반할 떄 발생하는 오류를 통지하거나 제어용 메시지를 통지할 때 사용
    - ARP - IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용

### LAN 드라이버

LAN 어댑터의 하드웨어를 제어한다.

### LAN 어댑터

실세 송, 수신 동작, 즉 케이블에 해새 신호를 송,수신하는 동작을 실행

## 소켓의 실체는 통신 제어용 제어 정보

프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 사지고 있으며, 통신 동작을 제어하기 위한 제어 정보를 기록한다

- 통신 상대의 IP주소
- 포트 번호
- 통신 동작의 진행 상태

본래 소켓은 개념적이고 실체가 없기 때문에 이런 제어 정보나 이것을 기록한 메모리 영역이 소켓의 실체라고 생각하는 것 같다

> 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 움직인다
> 

한 행이 하나의 소켓에 해당한다

소켓을 만든다는 동작은 이곳에 새로 한 행의 제어 정보를 추가하고 ‘여기부터 통신을 시작하는 곳’이라는 식으로 상태를 기록하거나 송,수신 데이터를 일시적으로 저장하는 버퍼 메모리를 준비하는 등 통신을 준비하는 작업이다.

> PID(Process ID) : 각 프로그램을 식별하기 위해 OS가 할당하는 번호
> 

맥북에서는 현재 열린 포트 목록을 확인하려면

```bash
sudo lsof -iTCP -sTCP:LISTEN -n -P
sudo lsof -PiTCP -sTCP:LISTEN
```

첫번째 명령어는 -n -P 옵션을 사용해서 호스트 및 포트 번호를 숫자로 표시했다. 이렇게 하면 호스트 및 포트의 이름을 확인하지 않아도 되서 더 빠르게 결과를 얻을 수 있다고 한다

두번째 명령어는 TCP 프로토콜을 사용하는 연결 중 LISTEN 상태인 것들만 보여준다. 현시 시스템에서 listening TCP 포트만 표시된다

근데 사용해보니 결과는 같았다

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/bd7c2452-2adc-40ad-b294-17aabaee8de2)  

~~(혹시 몰라서 정보들은 가렸다)~~

netstat 명령어를 치면 PID는 나오지 않지만 Foreign Address가 나온다. 

아무튼 PID가 1720이라면 Local Address IP주소에 할당한 LAN 어댑터를 사용하여 Foreign Address의 IP주소를 할당한 상태와 통신하고 있다. 로컬 시스템 뒤에 붙은 포트번호와 원격 시스템의 주소뒤에 붙은 포트번호를 알 수 있다. 만약 로컬 시스템과 원격 시스템의 IP주소가 0.0.0.0이라면 아직 통신이 시작되지 않았기 때문에 IP주소가 정해지지 않은 것이라고 해석할 수 있다.

## Socket을 호출했을 때의 동작

브라우저가 socket이나 connect라는 Socket 라이브러리의 프로그램 부품을 호출했을 때 프로토콜 스택의 내부는 어떻게 움직일까?

![image](https://github.com/ninaaano/book-reading-recode/assets/95615105/aafc75f8-6f13-4e3c-84b5-23071c87bb5b)


소켓을 호출하여 소켓을 만들 것을 의뢰하면 프로토콜 스택이 한 개의 소켓을 만든다. 이때 프로토콜 스택이 최초로 하는 일은 소켓 한 개 분량의 메모리 영역을 확보하는 것이다. 

소켓의 제어 정보를 기록하는 메모리 영역은 처음부터 존재하는 것이 아니다. 이것만으로는 어떤 역할도 하지 못하기 때문에 내용에 해당하는 제어 정보를 기록한다. 이 시점에서 소켓은 작성된 직후라서 송,수신 동작이 시작하지 않은 초기 상태이므로 이 제어 정보를 소켓의 메모리 영역에 기록하는데, 이 과정을 통해 소켓이 만들어 진다.

> 소켓을 만들 때 한 개의 메모리 영역을 확보하고 초기 상태라는 것을 이 영역에 기록한다
> 

소켓이 만들어지면 소켓을 나타내는 디스크립터를 애플리케이션에 알린다. 

> 디스크립터?
프로토콜 스택의 내부에 있는 다수의 소켓 중 어느 것을 가리키는 지를 나타내는 번호표와 같은 정보
> 

디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송, 수신 동작을 의뢰할 때 디스크립터를 통지한다. 소켓에는 누구와 누가 통신하고 있는지, 어떤 상태인지 등의 정보가 전부 기록되어 있어 디스크립터가 어느 소켓인지를 나타내면 필요한 정보는 전부 프로토콜 스택쪽에서 알 수 있다.

이렇게 통신 상대의 정보를 애플리케이션에서 일일이 통지받을 필요가 없어진다

# [STORY 02] 서버에 접속한다

## 접속의 의미
소켓을 만들면 애플리케이션(브라우저)은 connect를 호출한다. 그러면 프로토콜 스택은 자기쪽의 소켓을 서버측의 소켓에 접속한다. 이더넷이나 통신 회선 등의 케이블은 항상 접속된 상태에 있기 때문에 케이블을 연결하지 않거나 분리하지 않는다. 따라서 통신 상태와의 사이에서 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송,수신이 가능한 상태로 만드는 동작을 설명해야 하는데, 접속한다는 의미는 뭘까?

이더넷이나 통신 회선은 항상 케이블이 연결되어 있어서 언제든지 신호를 보낼 수 있다. 데이터를 신호로 변환하여 송신하기만 하면 언제든지 통신이 가능하다. 소켓을 만든 직후에 애플리케이션에서 데이터 송신 의뢰가 오면 프로토콜 스택은 어떻게 될까?

소켓을 만든 직후는 아무것도 기록되어 있지 않기 때문에 통신 상대가 누구인지 모른다. 이 상태에선 송신 의뢰가 와도 데이터를 어디로 보낼지 모른다. 브라우저는 URL을 바탕으로 서버의 IP주소를 조사하고, 포트 번호는 80번을 사용하도록 규칙으로 정해져 있으므로 필요한 정보를 안다고 할 수 있다.
그러나 브라우저가 알고있는 동작만으로는 부족하다. socket을 호출하여 소켓을 만드는 동작만으로는 프로토콜 스택에 아무것도 전달되지 않는다.

`서버의 IP주소나 포트 번호를 프로토콜 스택에 알리는 동작`이 필요한데, 이것이 접속 동작의 한 가지 역할이다

### 그렇다면 서버측은?

서버측에도 소켓이 만들어졌지만 서버측의 프로토콜 스택도 클라이언트측과 마찬가지로 소켓을 만드는 동작만으로는 통신상대를 알 수 없다. 또한 서버측은 애플리케이션에서도 상대를 알수 없으므로 이대로는 상태를 알 수 없는 상태에 있다. 

그래서 클라이언트에서 자신의 IP주소와 포트번호를 알려 통신하려는 클라이언트가 있다는 것을 서버측에 전달한다. 그럼 서버측의 프로토콜 스택도 클라이언트의 정보를 가질 수 있다. 이와 같이 `서버측에 통신 동작의 개시를 전달하는 것`도 접속 동작의 역할 중 하나이나.

### 접속 동작

통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송,수신이 가능한 상태로 만드는 것 → 클라이언트 측의 IP주소나 포트 번호를 서버에 알리는 것

> 제어 정보? 데이터의 송,수신 동작을 제어하기 위한 정보이며, IP주소나 포트번호
> 

접속 동작에서 주고 받는 제어 정보는 통신의 규칙으로 정해져 있다. 규칙에 따라 접속 동작을 실행하면 필요한 정보가 전달되고 데이터를 송,수신할 수 있는 상태가 된다.

- 버퍼메모리
송,수신하는 데이터를 일시적으로 저장하는 메모리 영역

버퍼 메모리의 확보도 접속 동작을 할 때 실행되는데, 이것이 접속한다는 동작의 의미이다.

## 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

제어 정보는 크게 두 종류가 있다.

- 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보

접속 동작 뿐 아니라 데이터를 송,수신하는 동작이나 연결을 끊는 동작도 포함하여 통신 동작 전체에서 어떤 정보가 필요한지 검토하여 내용을 TCP 사양으로 규정하고 있다.

제어 정보를 패킷의 맨 앞부분에 배치하는 것부터 헤더라고 부른다. 헤더도 여러 종류가 있다

- TCP 헤더
- 이더넷 헤더(=MAC 헤더)
- IP 헤더

헤더의 각 항목의 의미를 알면 통신 동작을 알 수 있다.

- 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보

애플리케이션에서 통지된 정보, 통신 상태로부터 받은 정보 등이 수시로 기록된다. 소켓의 제어 정보는 프로토콜 스택의 프로그램와 일체화 되어있다. 

소켓에 기록한 제어 정보는 상대 측에서 볼 수 없다.

소켓에 기록하는 제어 정보는 프로토콜 스택을 만드는 사람에 따라 달라지므로 간단히 설명할 수 없다.

> 통신 동작에 이용하는 제어 정보는 두 가지이다
> - 헤더에 기입되는 정보
> - 소켓(프로토콜 스택의 메모리 영역)에 기록되는 정보


## 접속 동작의 실제

애플리케이션이 Socket 라이브러리의 connet를 호출하면 어떻게 될까?

```
connect(<디스크립터>, <서버측의 IP 주소와 포트번호>, ...)
```

서버측의 IP주소와 포트 번호를 쓰면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다. 그럼 TCP 담당 부분은 IP주소로 표기된 상대, 즉 서버의 TCP 담당 부분과의 사이에 제어 정보를 주고 받는다.

- 데이터 송,수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만든다

> 헤더에는 뭐가 들어 있을까?
송신처, 수신처의 포트번호
> 

이를 통해 송신처가 되는 클라이언트 측의 소켓과 수신처가 되는 서버측의 소켓을 지정할 수 있다.

⇒ 접속해야 하는 소켓이 어느 것인지 확실히 하고 컨트롤 비트인 SYN 비트를 1로 만든다. 이렇게 접속이 된다

```
접속 동작의 첫 걸음은 TCP 담당 부분에서 접속을 나타내는 제어 정보를 기록한 TCP 헤더를 만드는 것이다. 
그리고 TCP 헤더의 송신처와 수신처의 포트 번호로 접속하는 소켓을 지정한다
```

여기까지 TCP 헤더를 만들었다. 이제 이걸 어떻게 해야할까?

이것을 IP 담당 부분에 넘겨서 송신하도록 의뢰한다. 그럼 얘네가 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 TCP 담당 부분에 건네준다.

서버측의 TCP 담당 부분이 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아낸다.

→ 접속을 기다리는 상태에 있는 소켓 중 TCP 헤더의 수신처 포트 번호와 같은 번호로 적힌게 해당 소켓이다

이걸 발견하면 여기에 필요한 정보를 기록하고 접속 동작이 진행중이라는 상태가 된다. 이 과정이 끝나면 서버의 TCP 담당 부분은 응답을 돌려보낸다

요약하자면, 애플리케이션에서 connect로 접속을 할 때 서버 측의 IP 주소와 포트 번호를 쓰면 이게 프로토콜 스택의 TCP 담당에게 전달이 된다. 그럼 이게 서버의 TCP 담당 부분과 정보를 주고 받는다. 그럼 헤더가 만들어지는데 이걸 IP 담당 부분에 넘겨서 의뢰하고, 패킷을 서버에 보내면 서버 측 IP 담당 부분이 이걸 받아 TCP 담당에게 준다. 그럼 이 TCP 담당이 헤더를 조사해서 소켓을 찾아내고 필요한 정보를 기록하고 응답을 돌려보낸다

이해가 안되면 그림과 함께보자.

응답을 돌려보낼 땐 ACK라는 컨트롤 비트도 1로 만든다. TCP 헤더를 IP 담당 부분에 건네서 클라이언트에 반송하도록 의뢰한다

패킷이 클라이언트로 돌아오면 TCP 담당 부분에 도착한다. TCP 헤더를 조사해서 서버측의 접속 동작이 성공했는지 확인한다 (SYN이 1이면 성공이다). 그럼 소켓에 서버의 IP주소나 포트 번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록한다.

서버가 응답을 돌려보낼때 ACK 비트를 1로 만들었는데, 이것과 같이 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만든 TCP 헤더를 반송하고, 이것이 서버에 도착하면 접속 동작의 대화가 끝난다

사실 소켓은 무언가로 연결되어 있진 않지만 연결 된 파이프가 있다고 가정하고 이걸 커넥션이라고 부른다. 커넥션은 데이터의 송,수신 동작을 계속하고 있는 동안, close를 호출하여 동작을 끊을 때까지 계속 존재한다. 커넥션이 이루어지면 connect의 실행이 끝나면서 애플리케이션을 제어할 수 있게 된다.


# [STORY 03] 데이터를 송,수신한다

## 프로토콜 스택에 HTTP 리퀘스트 메세지를 남긴다

애플리케이션이 write를 호출하여 송신 데이터를 프로토콜 스택에 건네주고, 이걸 받은 프로토콜 스택이 송신 동작을 실행하는데 중요한 점이 있다

- 프로토콜 스택은 받은 데이터의 내용을 알지 못한다
    - 송신 데이터의 길이만큼 바이너리 데이터가 1바이트씩 차례로 나열되어 있다고 인식할 뿐이다

프로토콜 스택은 받은 데이터를 먼저 자체 내부에 있는 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주기를 기다린다.

> 왜 저장하는데?
> 

송신을 의뢰할 때 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션의 종류나 만드는 방법에 따라 결정된다. 데이터의 길이는 프로토콜 스택에서 제어할 수 없다.

어느정도 저장한 후 여러 요소를 바탕으로 판단한다

- 한 패킷에 저장할 수 있는 데이터 크기
    - 프로토콜 스택은 MTU라는 매개변수를 바탕으로 판단함
    - 패킷의 길이가 길어져서 네트워크의 이용효율이 높아지지만 버퍼에 머무는 시간 만큼 송신 동작이 지연될 우려가 있다
- 타이밍
    - 프로토콜 스택은 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신한다
    - 지연은 적어지지만 이용 효율이 떨어진다

이 두 방법 외에도 애플리케이션 측에서 송신의 타이밍을 제어하는 것도 있다. 데이터 송신을 의뢰할 때 옵션을 지정할 수 있으며 버퍼에 머물지 않고 바로 송신하는 것을 지정하면 프로토콜 스택은 버퍼에 머물지 않고 송신 동작을 실행한다.

브라우저같이 대화형 애플리케이션이 서버에 메세지를 보낼 때 버퍼에 머무는 시간만큼 응답 시간이 지연되으로 이 옵션을 사용하는 경우가 많을 수 있다

- MTU
    
    패킷 한개로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1,500 바이트
    
- MSS
    
    헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이


## 데이터가 클 때는 분할하여 보낸다

블로그나 게시판에 긴 글을 작성하는 것 같이 긴 데이터들은 한 개의 패킷에 들어가지 않을 수도 있다. 이런 경우 송신 버퍼에 저장된 데이터는 MSS의 길이를 초과하므로 다음 데이터를 기다릴 필요가 없다. 따라서 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS 크기에 맞게 분할하고 그 조각을 한 개씩 패킷에 넣어서 송신한다


## ACK 번호를 사용하여 패킷이 도착했는지 확인한다

TCP 담당 부분은 데이터를 조각으로 분할하고 몇번 째 바이트인지 세어두고 그 값을 TCP헤더에 기록하는데 시퀀스 번호라는 항목이 해당된다. 

ACK 번호를 되돌려주는 동작을 수신 확인 응답이라고 부르며, 송신 측은 이것을 통해 상대가 어디까지 수신했는지 파악한다

- ACK 번호 = 수신을 완료한 바이트  + 1
- 최초 3way handshake를 할 때 초기 시퀀스 번호를 함께 주고 받는다
    - 초기 시퀀스 번호를 악용할 수 있기 때문에 난수로 설정하여 미리 주고받는다
- 이후 최초 시퀀스 번호 + 데이터의 크기 만큼의 데이터를 수신했다면 그것에 대한 확인으로 지금까지 수신한 바이트 + 1 숫자를 ACK로 지정하여 응답한다

보낸 패킷에 헤더 길이를 빼면 수신한 데이터의 크기를 유추 할 수 있다

- 이후 송신할 데이터를 시퀀스 번호로 지정하고 송신하고, 동일하게 수신한 마지막 바이트 + 1을 ACK로 응답한다
- 시퀀스 번호와 ACK 번호로 누락된 패킷 여부를 알 수 있다. 만일 누락되었으면 송신 버퍼 메모리에 저장되어 있는 데이터를 재송신한다.

> 시퀀스 번호와 ACK 번호로 패킷이 수신측에 도착한 것을 확인한다
>
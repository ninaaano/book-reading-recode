# [Story 01] HTTP 리퀘스트 메세지를 작성한다

## URL 입력

- URL은 우리가 알고 있는 http 뿐 아니라 ftp, file, 등등 여러가지가 존재한다.
    - 브라우저에 여러 프로토콜 존재한다
        - 브라우저는 여러 클라이언트 기능을 가지고 있는 복합적인 소프트웨어이기 때문
    - 브라우저에서 http 요청 뿐 아니라 파일 다운로드/업로드 등의 기능도 있다.
    - 어느 기능을 사용하는지 url 에 명시된 프로토콜로 판단할 수 있다.
- URL에 엑세스 대상에 따라서 여러 정보를 담는다.
    - 웹 서버 요청일 경우 파일 경로, 포트 번호 등을 담아서 보낼 수 있다.
    - 모든 URL에는 앞에 엑세스 대상에 따라서 다른 프로토콜을 명시하고 있다. (http, ftp 등등)

## **브라우저의 URL 해독**

웹 서버에 엑세스 하는 경우를 기반으로 설명한다.

- URL에 파일 경로가 포함되어 있을 수 있다 → ‘/’ 를 기준으로 디렉토리 구조와 파일명을 명시하여 url에 포함한다.
- 마지막에 파일명을 명시하지 않는 경우
    - 기본 파일명을 서버측에 설정하여 생략된 경우 사용한다. (index.html, default.htm 등등)
- 마지막에 디렉토리를 생략한 경우
    - 루트 디렉토리의 기본 파일을 읽는 것으로 간주한다.
- 마지막에 경로에 /가 생략된 경우 (ex. http://www.web.com/path)
    - 이 경우 마지막 값이 파일명인지 디렉토리인지 알 수 없다.
    - 다음과 같은 경우 우선 매칭되는 **파일명**이 있는지 확인하고, 없다면 매칭되는 **디렉토리명**이 있는지 확인한다.

## **HTTP기본 개념**

- URL 해독 후 액세스 해야하는 위치가 판단된다. 그때부터 명시된 프로토콜 (이 경우에는 HTTP)에 따라서 액세스를 진행한다.
- HTTP 프로토콜의 요청 메세지가 담고 있는 내용
    1. 무엇을 - URI 데이터를 저장한 경로만 쓰거나 URL을 그대로 쓸 수도 있다.
    2. 어떻게 - 메소드 (GET, POST, PUT 등등)
- 응답 메세지가 담고 있는 내용
    1. 결과 데이터
    2. status code - 실행 결과의 상태에 대한 정보

## **HTTP 리퀘스트 메세지를 만든다**

- 우선 URL을 판단하여 웹 서버와 파일 경로 및 파일명을 해석한 후에 HTTP 요청 메세지를 만든다.
- 첫번째 행 - Request Line
    - 메소드 - 여러 종류의 메소드 중 웹 서버에 어떻게 전달할지 메소드에 담아서 판단한다.
    - URI - 파일이나 경로명
    - HTTP 버전
- 두번째 부터 - Headers
    - 부가적인 자세한 정보를 헤더에 추가한다.
    - 날짜, 데이터 종류, 언어, 압축 형식 등등
- 공백 라인 이후 - Request Body
    - 송신할 데이터를 메세지 본문에 기재한다.
    - 주로 POST 요청인 경우 바디에 데이터를 담아서 요청한다.

## **리퀘스트 메세지를 보낸 이후 응답이 돌아온다.**

- 기본적으로 첫번째 행을 제외하고 요청 메세지와 비슷한 형태를 지닌다.
- 첫번째 행 -
    - 요청 실행 결과 status code
    - status 코드의 응답 문구 (Not Found)
- 응답이 오면 메세지를 추출해서 화면에 표시한다.
- 문장만 이루어진 응답 데이터가 아닌 경우
    - 추가적으로 이미지나 영상을 담고 있는 경우 응답 문장에 tag를 추가하여 명시한다.
        - ex. `<img src="{이미지경로}" />`
    - tag가 존재한다면
        - 우선 공백으로 비워둔다.
        - 이후 추가 웹 서버 액세스하여 태그에 쓰여있는 경로로 URI를 만들어서 요청 메세지를 보낸다.
- 하나의 요청 메세지에는 하나의 URI 만 쓰기 때문에 여러 파일이 필요하면 매번 요청을 보내야 한다.

# [Story 02] 웹 서버의 IP 주소를 DNS 서버에 조회한다

## **IP 주소의 기본**

- 브라우저가 담당하는 일 → URL 해독, HTTP 메세지 만들기
- OS가 담당하는 일 → 메세지를 네트워크로 송출
    - 따라서 브라우저가 위 업무는 OS에 위임하여 메세지를 송신한다.
- 이때 URL에서 해석한 도메인명의 IP 주소를 조사해야 한다.

## **TCP/IP 기본 개념**

- 서브넷 - 여러 PC가 하나의 허브에 연결되어 있는 단위
- **여러 서브넷을 라우터로 연결하여 네트워크 전체를 구성한다.**
- 네트워크 주소를 00동 00번지의 단위로 표현할 수 있다.
    - 00동 → 서브넷에 할당된 네트워크 번호
    - 00번지 → 호스트 번호
- **네트워크 번호 + 호스트 번호**가 IP 주소를 구성한다.
- 라우터와 허브를 통해서 **네트워크 주소를 계속 중계**하면서 액세스 대상을 찾아간다.
- **기본적인 흐름**
    - 송신측이 메세지를 보냄 → 가까운 허브가 운반하여 가까운 라우터에 송신 → 라우터에서 다음 라우터를 판단 → 서브넷의 허브가 해당 라우터까지 메세지를 송신함 → 반복하여 최종 도착지에 데이터가 도착

### **IP의 구조**

- 32비트 디지털 데이터
- 8비트씩 . 으로 구분하여 10진수로 표기 - 255.255.255.255
- 네트워크 번호(서브넷 번호)와 호스트 번호를 판단하기 위해 넷마스크 정보를 IP에 더한다.
- 넷마스크 번호도 동일하게 32비트 디지털 데이터이다.
    - 1로 표기된 비트까지가 네트워크 번호
    - 0으로 표기된 비트를 호스트 번호로 판단한다.
    - 바이트 단위로 반드시 맞아 떨어지지는 않는다.
- 호스트 번호가 모두 0인 경우 - 서브넷 자체를 나타냄
- 호스트 번호가 모두 1인 경우 - 서브넷 기기 전체에 대한 브로드캐스트를 나타냄

## **도메인명과 IP 주소를 구분하는 이유**

- 반드시 IP 주소가 있어야지 수신 상대와 연결될 수 있는데 번호로 구성된 IP를 기억하기는 어렵기 때문에 도메인명을 쓰도록 한다.
- 도메인명 만으로 네트워크 통신을 하게 된다면 주소에 대한 바이트가 균일하지 않고 지나치게 클 수 있다.
    - 데이터 운반 동작에 더 많은 시간이 걸려 속도가 느려진다.
- 따라서 사용자는 도메인명만 기억하면 해당 IP 주소를 알아서 찾아주는 **DNS**를 사용한다.

### **Socket 라이브러리가 IP 주소 찾는 기능을 제공**

- DNS 동일하게 요청 메세지 + 응답 메세지의 구조로 데이터를 찾아내는 것이다.
- DNS 서버에 요청 메세지를 보내어 도메인명을 의뢰하는 DNS 클라이언트는 **DNS 리졸버**이다.
- DNS resolution → DNS 원리로 IP 주소를 조사하는 것 (DNS 리졸버가 수행함)
- **DBS 리졸버는 Socket 라이브러리에 내장된 프로그램이다.**
    - Socket 라이브러리에는 네트워크 기능과 관련된 프로그램이 집합해 있다.

### **리졸버를 이용하여 DNS 서버를 조회한다**

- Socket 라이브러리에 리졸버 메소드에 의뢰하고자 하는 도메인 명을 명시하면 IP 주소를 조회할 수 있다.

### **리졸버 내부의 작동**

- 어플리케이션(브라우저)에서 리졸버를 호출하면서 어플리케이션은 잠시 대기한다. (리졸버로 제어가 넘어가 실행된다. 이때부터 실행주체는 Socket 라이브러리의 리졸버이다)
- DNS 서버에 응답 메세지를 만들어 보낸다.
- **메세지 송신 동작은 OS의 프로토콜 스택이 수행한다. LAN 어댑터를 경유하여 목표서버에 메세지가 전달된다.**
- DNS 서버가 해당 메세지를 해석하여 결과를 찾는다.
- 응답이 오면 `프로토콜 스택 → 리졸버가 내용을 해독하여 IP 주소 추출 → 어플리케이션에 주소전달` 하는 단계를 밟는다.
- DNS 서버 주소 정보는 ?
    - TCP/IP 설정 항목으로 컴퓨터에 미리 설정되어 있다.


# [Story 03] 전 세계의 DNS 서버가 연대한다

### **DNS 서버의 기본 동작**

- DNS 서버는 조회 메세지를 받고 그것에 대해 응답을 한다.
- 조회 메세지 내용
    - 이름: 서버나 메일 배송 목적지 (@뒤 호스트)
        - ex. [www.example.com](http://www.example.com/)
    - 클래스: 이전에 필요했으나 요즘에는 항상 인터넷을 나타내는 클래스 ‘IN’으로 표기됨
    - 타입: 다음마다 응답 형태가 바뀐다.
        - A: 이름에 지원되는 IP 주소
        - MX: 메일 배송 목적지
- DNS 서버에서 위 3가지가 일치하는 응답 정보를 찾아서 등록된 IP 주소 등을 회신한다.
- MX, 메일 서버에 대한 응답인 경우
    - 메일 서버의 우선순위 + 메일 서버의 이름, 해당 메일 서버의 IP 주소를 함께 회신한다.
- DNS 서버에서 취급하는 타입은 여러개가 있다.
    - PTR, NS, SOA, CNAME 등등

### **도메인의 계층**

- 정말 많은 서버의 수가 존재하기 때문에 한대의 DNS 서버에 모든 정보를 등록할 수 없다. **정보를 분산시켜 여러대의 DNS 서버에 등록**해놓고 조회하는 정보를 찾아서 응답하는 구조로 되어있다.

### **도메인명**

- DNS 서버에 등록되어 있는 도메인명은 계층적 구조를 가지고 있다.
- 도메인의 계층은 .점으로 구분되어 있다. (ex. [www.example.com](http://www.example.com/) 각각의 www, example, com 이 계층을 나타냄)
    - 위의 경우 com 도메인 하위에 example 도메인 하위에 www 도메인이 있는 것 (서브 도메인)
- 하나의 도메인에 대한 정보들은 하나의 DNS 서버에서 모두 관리한다.
    - DNS 서버는 다수의 도메인을 관리할 수 있지만 같은 도메인인 정보들은 모두 한대의 DNS 서버에 존재한다.
- 가장 먼저 출연하는 도메인이 서버의 이름, 최하위 서브 도메인이다 (예, www, api, dev 같은 경우)

### **담당 DNS 서버를 찾아 IP 주소를 가져온다**

- 여러 DNS 서버가 존재하기 때문에 중요한 것은 어느 DNS 서버에 원하는 정보가 있는지 판단하는 것이다.
- 그 방법으로 상위 도메인에 하위 도메인을 등록하여 찾아갈 수 있는 구조로 설계했다.
    - com 도메인에 [example.com](http://example.com/) 도메인이 등록되어 있는 구조
- com, kr 등등은 최상위 도메인이 아니다 → root 도메인이 존재하여 거기에 com, kr 등등의 도메인이 등록되어 있다.

### **루트 도메인**

- 최상위 도메인으로 할당된 IP 주소는 13개 뿐이다.
- 그렇기 때문에 루트 도메인의 정보를 모든 DNS 서버에 등록할 수 있다 → 기본으로 DNS 서버 설정 파일에 등록되어 있다.
- 그 어떤 DNS 서버에서도 루트 도메인 DNS 서버로 이동할 수 있는 주소를 확보한다.

### **클라이언트가 [www.example.com의](http://www.example.xn--com-yh0o/) IP 주소를 구하는 방법**

- 컴퓨터에 설정되어 있는 가장 가까운 DNS 서버로 조회를 요청 → 없으면 루트 도메인 서버로 메세지 전송
- (존재하지 않는 경우) 루트 도메인으로 이동 → 없으면 com 도메인 주소 반송
- 루트 도메인에 등록된 com 도메인 서버로 이동 → 없으면 [example.com](http://example.com/) 도메인 주소 반송
- com 도메인 서버에 등록된 [example.com](http://example.com/) 도메인 서버로 이동 → 반복
- 원하는 도메인 IP 주소를 응답
- 그것을 가장 가까운 DNS 서버에서 클라이언트에게 응답
- 도메인이 같은 DNS 서버에 존재할 수 있으므로 도메인 개수만큼 서버를 꼭 이동하는 것은 아니다.

### **DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다**

- DNS 서버에서 한번 조사한 이름을 캐시에 저장한다.
- 이후에 저장할 경우 루트 도메인애서부터 찾는 것이 아니라 캐싱된 도메인의 하위 도메인부터 찾을 수 있다.
- 존재하지 않은 도메인인 경우도 캐싱하여 빠르게 응답한다.
- 유효기간에 따라서 정보를 삭제하고 캐시 응답인지 서버 응답인지 알려준다. (정보 업데이트 고려)

# [Story 04] 프로토콜 스택에 메세지 송신을 의뢰한다

### **데이터 송수신 동작의 개요**

- 메세지 전송을 OS 내의 **프로토콜 스택**에 위임한다.
- 반드시 웹 요청 메세지 뿐 아니라 컴퓨터의 모든 네트워크 관련 동작에 공통인 부분이다.
    - 디지털 데이터 송수신이 필요한 부분은 모두 할당된다.
- 프로토콜 스택에 의뢰하여 메세지를 전송할 때도 **Socket 라이브러리**를 사용한다.

### **소켓을 활용한 데이터 송수신 기본 동작 - 프로토콜 스택 담당**

1. 소켓을 생성 (서버와 클라이언트가 각각 소켓을 생성)
- 소켓은 데이터가 흐르는 통로의 입구와 같은 것이다.
1. 서버측의 소켓에 클라이언트 소켓 접속
2. 데이터 송 수신
3. 완료 후 파이프 분리 후 소켓 말소 (close는 어느 측에 해도 무방)
- 소켓 라이브러리는 어플리케이션으로부터 위 단계를 실행하도록 의뢰받고 그대로 프로토콜 스택에 중계하는 역할을 한다.

### **소켓의 작성 단계 - 소켓 라이브러리 메서드 활용**

- `디스크립터 = socket`을 생성
    - 디스크립터로 소켓을 식별
- `connect` 메서드로 (소켓 디스크립터, 대상 서버 IP 주소 및 포트번호 필요) 로 대상 서버와 접속
- `write` 메서드로 데이터 송신
- `read` 메서드로 데이터 수신
- `close` 메서드로 소켓 말소

### **파이프 연결하는 접속 단계**

- `connect` 라는 메서드에 인자로 소켓 디스크립터 + 서버 IP 주소 + 서버 포트 번호 가 필요하다.
- 프로토콜 스택은 connect에서 중계한 디스크립터로 데이터 송수신을 담당할 소켓을 판별한다.
- IP 주소는 컴퓨터를 식별할 수 있지만, 컴퓨터에 존재하는 여러 소켓 중 어느 것에 연결할지 알기 위해서는 포트 번호가 필요하다.
    - **포트 번호는 상대 소켓을 식별 !!**
    - 왜 소켓을 식별할 수 있는 디스크립터를 사용하지 않을까 ?
        - 디스크립터는 소켓을 생성한 어플리케이션에서 프로토콜 스택에 의뢰하도록 주는 것이다.
        - 상대에게 소켓 디스크립터를 넘겨주어도 정보가 없으므로 식별할 수 없다.
    - 포트 번호는 미리 지정한 규칙에 따라서 서로 알고있는 값이다. (웹 서버는 80, 메일은 25 등등)
    - 포트 번호도 충돌할 수 있기 때문에 중복되지 않도록 IANA에서 일괄 관리한다.
    - **클라이언트의 소켓 번호는 알아서 할당 후 접속 동작에서 서버에 통지한다. (이후 추가 설명)**

### **메세지를 주고받는 송수신 단계**

- 송신측에서 메모리에 송신 데이터를 준비한다. (HTTP request 메세지)
- `write`를 호출하며 소켓 디스크립터와 송신 데이터를 지정한다.
- 디스크립터로 지정된 소켓에 연결대상이 이미 접속 단계에서 지정이 되어있다. 목적지로 데이터를 송신한다.
- 이후 응답 메세지를 수신할 때는 `read`를 통해 수신 버퍼에 응답 메세지를 저장한다.
    - 수신 버퍼는 어플리케이션의 메모리 영역

### **연결 끊기 단계에서 송수신이 종료된다**

웹 서비스와 같은 경우 웹 서버에서 먼저 close를 호출한다. (어느측에서 먼저해도 상관없다)

- 웹 서버에서 `close()`를 호출
- 클라이언트가 `close()` 호출 여부를 응답받으면, 클라이언트도 `close()`를 호출하여 연결 끊기를 진행
- HTTP 프로토콜은 하나하나의 데이터를 별도의 것으로 취급하기 때문에 위 단계를 모든 데이터를 송수신 할때마다 반복하는 것이다.
    - 이것이 비효율적이라고 생각하여 나온것이 HTTP 1.1의 `keep-alive`
    - 더 이상 송수신할 데이터가 없는 경우에만 소켓을 말소하는 단계에 들어간다.